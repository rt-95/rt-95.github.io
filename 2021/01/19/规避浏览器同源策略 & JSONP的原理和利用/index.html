

<!DOCTYPE html>
<html lang="en" color-mode=light>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>规避浏览器同源策略 &amp; JSONP的原理和利用 - rt</title>
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="google" content="notranslate" />
  
  <meta name="description" content="1@ 前言前端尤其是 Js 越学越发觉得其灵活度是超出...">
  <meta name="author" content="rt">
  <link rel="icon" href="/images/icons/favicon-16x16.png" type="image/png" sizes="16x16">
  <link rel="icon" href="/images/icons/favicon-32x32.png" type="image/png" sizes="32x32">
  <link rel="apple-touch-icon" href="/images/icons/apple-touch-icon.png" sizes="180x180">
  <meta rel="mask-icon" href="/images/icons/stun-logo.svg" color="#333333">
  
    <meta rel="msapplication-TileImage" content="/images/icons/favicon-144x144.png">
    <meta rel="msapplication-TileColor" content="#000000">
  

  
<link rel="stylesheet" href="/css/style.css">


  
    
<link rel="stylesheet" href="https://at.alicdn.com/t/font_1445822_p6ry5n7lrr.css">

  

  
    
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css">

  

  
    
      
        
        
<link rel="stylesheet" href="https://cdn.bootcss.com/highlight.js/9.18.1/styles/nord.min.css" name="highlight-style" mode="light">

      
        
        
<link rel="stylesheet" href="https://cdn.bootcss.com/highlight.js/9.18.1/styles/nord.min.css" name="highlight-style" mode="dark">

      
  

  <script>
    var CONFIG = window.CONFIG || {};
    var ZHAOO = window.ZHAOO || {};
    CONFIG = {
      isHome: false,
      fancybox: true,
      pjax: false,
      loading: {
        gif: '/images/theme/loading.gif',
        lottie: ''
      },
      lazyload: {
        enable: true,
        only_post: 'false',
        loading: {
          gif: '/images/theme/loading.gif',
          lottie: ''
        }
      },
      donate: {
        enable: false,
        alipay: 'https://pic.izhaoo.com/alipay.jpg',
        wechat: 'https://pic.izhaoo.com/wechat.jpg'
      },
      galleries: {
        enable: true
      },
      fab: {
        enable: true,
        always_show: false
      },
      carrier: {
        enable: true
      },
      daovoice: {
        enable: false
      },
      preview: {
        background: {
          default: '',
          api: ''
        },
        motto: {
          default: '',
          typing: true,
          api: '',
          data_contents: '["data","content"]'
        },
      },
      qrcode: {
        enable: true,
        type: 'url',
        image: 'https://i.328888.xyz/2023/04/13/igT1lV.jpeg',
      },
      toc: {
        enable: true
      },
      scrollbar: {
        type: 'default'
      },
      notification: {
        enable: false,
        delay: 4500,
        list: '',
        page_white_list: '',
        page_black_list: ''
      },
      search: {
        enable: false,
        path: ''
      }
    }
  </script>

  

  

<meta name="generator" content="Hexo 6.3.0"></head>

<body class="lock-screen">
  <div class="loading" id="loading"></div>
  
    


  <nav class="navbar">
    <div class="left">
      
        <i class="iconfont iconhome j-navbar-back-home"></i>
      
      
        <i class="iconfont iconqrcode j-navbar-qrcode"></i>
      
      
        <i class="iconfont iconmoono" id="color-toggle" color-toggle="light"></i>
      
      
    </div>
    <div class="center">规避浏览器同源策略 &amp; JSONP的原理和利用</div>
    <div class="right">
      <i class="iconfont iconmenu j-navbar-menu"></i>
    </div>
    
      <div id="qrcode-navbar"></div>
    
  </nav>

  
  

<nav class="menu">
  <div class="menu-container">
    <div class="menu-close">
      <i class="iconfont iconbaseline-close-px"></i>
    </div>
    <ul class="menu-content"><li class="menu-item">
        <a href="/ " class="underline "> 首页</a>
      </li><li class="menu-item">
        <a href="/archives/ " class="underline "> 归档</a>
      </li><li class="menu-item">
        <a href="/about/ " class="underline "> 关于</a>
      </li><li class="menu-item">
        <a href="/articles/ " class="underline "> 文章</a>
      </li></ul>
    
      <div class="menu-copyright"><p>Powered by <a target="_blank" href="https://hexo.io">rt</a>  |  Theme - <a target="_blank" href="https://github.com/izhaoo/hexo-theme-zhaoo">zhaoo</a></p></div>
    
  </div>
</nav>
  <main id="main">
  <div class="article-wrap">
    <div class="row container">
      <div class="col-xl-3"></div>
      <div class="col-xl-6"><article class="article">
  <div class="wrap">
    <section class="head">
  <img   class="lazyload" data-original="/images/theme/post-image.jpg" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  draggable="false">
  <div class="head-mask">
    <h1 class="head-title">规避浏览器同源策略 & JSONP的原理和利用</h1>
    <div class="head-info">
      <span class="post-info-item"><i class="iconfont iconcalendar"></i>January 19, 2021</span>
      
      <span class="post-info-item"><i class="iconfont iconfont-size"></i>13569</span>
    </div>
  </div>
</section>
    <section class="main">
      <section class="content">
        
        <h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1@ 前言"></a>1@ 前言</h2><p>前端尤其是 Js 越学越发觉得其灵活度是超出一般脚本的。这篇文章，记录下自己对同源策略和 JSONP 的学习，也供有需要的同学参阅。</p>
<h2 id="2-同源策略"><a href="#2-同源策略" class="headerlink" title="2@ 同源策略"></a>2@ 同源策略</h2><p>想必搞安全的初期大都会读过道哥的那本**<code>白帽子</code>**,书里面靠前的位置就讲过同源策略，不过我想大部分人可能还是对这个概念了解的不是很透彻，我们一起再来温习温习。</p>
<blockquote>
<p>1995年，同源政策由 Netscape 公司引入浏览器。目前，所有浏览器都实行这个政策。</p>
</blockquote>
<blockquote>
<p>同源策略 （Same Origin Policy）是一种约定。</p>
<p>浏览器的同源策略，限制了来自不同源的 document 或脚本，对当前 document 读取或者设置某些属性。</p>
<p> ———- 《白帽子讲web安全》</p>
</blockquote>
<h3 id="2-1-介绍"><a href="#2-1-介绍" class="headerlink" title="2.1 介绍"></a>2.1 介绍</h3><p>那么，什么时候两个资源才算是同源呢？</p>
<p>影响两个资源是否同源主要看以下字段是否相同，如果一致，则会被认为是同源的。</p>
<ul>
<li>host(域名或者IP地址)</li>
<li>子域名</li>
<li>端口</li>
<li>协议</li>
</ul>
<p>举个简单的例子：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">http:<span class="hljs-regexp">//</span>test1.rt95.com/test.html<br>http:<span class="hljs-regexp">//</span>test2.rt95.com/test.html<br></code></pre></td></tr></table></figure>

<p>上面两个资源就是不同源的，因为他们的子域名不同 。</p>
<h3 id="2-2-限制范围"><a href="#2-2-限制范围" class="headerlink" title="2.2 限制范围"></a>2.2 限制范围</h3><p>当前，如果非同源，下面的行为会受到限制。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs">（1） Cookie、LocalStorage 和 IndexDB 无法读取。<br><br>（2） DOM 无法获得。<br><br>（3） AJAX 请求不能发送。<br></code></pre></td></tr></table></figure>

<h3 id="2-3-规避同源策略的方法"><a href="#2-3-规避同源策略的方法" class="headerlink" title="2.3 规避同源策略的方法"></a>2.3 规避同源策略的方法</h3><h4 id="1、Cookie"><a href="#1、Cookie" class="headerlink" title="1、Cookie"></a>1、Cookie</h4><p><strong>如果两个网页的一级域名相同，只是二级域名不同，可以通过设置document.domain 共享 Cookie</strong></p>
<ul>
<li>上面这句话其实略带迷惑性，容易想当然。其本质就是页面可以设置 document.domain 为当前子域或者比当前子域更高的域。而一个子域的 cookie 包含了其子域和所有比其更高的域的 cookie，下例实质上是间接设置了主站上的 cookie，而使得所有子域都能访问到 cookie。</li>
</ul>
<p>假如说我们现在有两个测试网站，仅仅是子域名不同，我们通过上面的原理来访问下 cookie 值。</p>
<p>测试网站为阮大佬的博客和书籍页面。</p>
<p>打开 <code>es6.ruanyifeng.com</code>,控制台改变域名：</p>
<p><img   class="lazyload" data-original="https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/jsonp/1.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ></p>
<p>然后设置一个 cookie 值：</p>
<p><img   class="lazyload" data-original="https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/jsonp/2.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ></p>
<p>继续到博客页面，控制台改变域名和之前相同，然后进行 cookie 访问：</p>
<p><img   class="lazyload" data-original="https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/jsonp/3.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ></p>
<p>这种方法只适用于 Cookie 和 iframe 的窗口，LocalStorage 和 IndexDB 不能使用此方法。</p>
<p>一般浏览器前端设置 cookie 的插件，像 EditThisCookie 这种，还是后端设置 cookie，如果没有特殊的用处，都是将 cookie 的 domain 字段设置为当下所属的域，但是如果此域存在一个 xss, 组合利用的话，可以修改 cookie 让另一个子域跨域访问到。</p>
<p>下面再给出一个比较有意思的跨域获取 cookie 的思路</p>
<ul>
<li>现在在 cms1.test.ink 域下面有一个 1.html,内嵌一个 cms2.test.ink 的 2.html 页面:</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&#x27;http://cms2.test.ink/2.html&#x27;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&#x27;100&#x27;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&#x27;100&#x27;</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">textarea</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;zhaochao&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">textarea</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>

<ul>
<li>而 cms2.test.ink 域下面的 2.html 内容如下，其内容是跳转到 cms1.test.ink 域下的 3.html，并且带上自己的cookie：</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>=<span class="hljs-string">&quot;http://cms1.test.ink/3.html?&quot;</span>+<span class="hljs-variable language_">document</span>.<span class="hljs-property">cookie</span>;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>

<ul>
<li>cms1.test.ink 域下面的 3.html 用来接收跨域传递过来的参数，并写在父页面的文本框里：</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-variable language_">window</span>.<span class="hljs-property">parent</span>.<span class="hljs-property">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;zhaochao&quot;</span>).<span class="hljs-property">value</span>=<span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>.<span class="hljs-title function_">toString</span>().<span class="hljs-title function_">substring</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>.<span class="hljs-title function_">toString</span>().<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&quot;?&quot;</span>));</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure>

<ul>
<li><p>访问 cms1.test.ink&#x2F;1.html,内嵌 cms2.test.ink&#x2F;2.html，带 cookie 跳转到 cms1.test.ink&#x2F;3.html 接收参数，写到主页面。</p>
<p><img   class="lazyload" data-original="https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/jsonp/22.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ></p>
</li>
</ul>
<h4 id="2、iframe"><a href="#2、iframe" class="headerlink" title="2、iframe"></a>2、iframe</h4><p>如果两个网页不同源，那么就不能拿到对方的 dom ，像 iframe 和 window.open 窗口，与父窗口无法进行通信。</p>
<p>像在父窗口上使用下述方法来获取 iframe 的标签，就会因为不同源而报错。（本地嵌入一个百度页面进行测试）</p>
<p><img   class="lazyload" data-original="https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/jsonp/4.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ></p>
<p>如果父子窗口只是二级域名不同，可以效仿上一点 Cookie 的跨越访问那样，设置 <code>document.domain</code> 一致即可访问。</p>
<p>下面介绍下完全不同源的网站进行跨域访问的三种方法。</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">片段识别符（fragment identifier）<br><span class="hljs-keyword">window</span>.name<br>跨文档通信API（<span class="hljs-keyword">Cross</span>-document messaging）<br></code></pre></td></tr></table></figure>

<h4 id="3、片段识别符"><a href="#3、片段识别符" class="headerlink" title="3、片段识别符"></a>3、片段识别符</h4><p>片段识别符（fragment identifier)也就是前端开发中所说的锚点，即 URL 的 <code>#</code> 之后的内容。如果知识改变片段识别符，页面不会重新刷新。</p>
<p>这种父子间的访问方法已经浮出水面：父窗口向子窗口的片段标识符中写入数据，而子窗口可以通过创建一个监听 hash 值的方法来获取父窗口传过来的数据，从而达成通信。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">// 父窗口写入数据</span><br><span class="hljs-selector-tag">var</span> <span class="hljs-attribute">src</span> = originRL + <span class="hljs-string">&#x27;#&#x27;</span> + data;<br>$(<span class="hljs-string">&#x27;iframe&#x27;</span>)<span class="hljs-selector-class">.get</span>(<span class="hljs-number">0</span>)<span class="hljs-selector-class">.src</span> = <span class="hljs-attribute">src</span>；<br><span class="hljs-comment">// 子窗口查看数据</span><br>window<span class="hljs-selector-class">.location</span>.href； <span class="hljs-comment">// # 之后有 data 的值</span><br></code></pre></td></tr></table></figure>

<p><img   class="lazyload" data-original="https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/jsonp/5.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ></p>
<p><img   class="lazyload" data-original="https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/jsonp/6.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ></p>
<h4 id="4、window-name"><a href="#4、window-name" class="headerlink" title="4、window.name"></a>4、window.name</h4><p>window.name 这个属性有个特定就是，无论是否同源，只要在同一个窗口里，前一个网页设置了这个属性，后一个网页就可以读取到它。（这种方法只能是子窗口向父窗口发送数据）</p>
<p>我们依旧拿上面的例子来演示：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">在父窗口中打开子窗口，键入 <span class="hljs-keyword">window</span>.name 的值 <span class="hljs-comment">-----&gt;</span><br>然后改变 <span class="hljs-keyword">window</span>.<span class="hljs-keyword">location</span> 的值进入到父窗口  <span class="hljs-comment">-----&gt;</span><br>父窗口中获得子窗口的标签，然后读取其 <span class="hljs-keyword">window</span>.name 的值<br></code></pre></td></tr></table></figure>

<p><img   class="lazyload" data-original="https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/jsonp/7.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ></p>
<p><img   class="lazyload" data-original="https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/jsonp/8.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ></p>
<h4 id="5、window-postMessage"><a href="#5、window-postMessage" class="headerlink" title="5、window.postMessage"></a>5、window.postMessage</h4><p>上面的方法都属于程序猿们私下闲着没事干破解出来的，而 HTML5 为了解决这个问题。引入了一个全新的 API ：跨文档通信 API （Cross-document-messaging),它为 window 对象多增添了一个 window.postMessage() 的方法，允许跨窗口通信，不管是否同源。</p>
<blockquote>
<p>举例来说，父窗口<code>http://aaa.com</code>向子窗口<code>http://bbb.com</code>发消息，调用<code>postMessage</code>方法就可以了</p>
</blockquote>
<p>我们来看看 w3c 中定义 的 postMessage() 方法的定义</p>
<blockquote>
<p>targetWindow .postMessage（message，targetOrigin，[ transfer ]）</p>
<ul>
<li><p><em>targetWindow</em></p>
<p>对将接收消息的窗口的引用。获得此类引用的方法包括：<code>Window.open</code> （生成一个新窗口然后引用它），<code>Window.opener</code> （引用产生这个的窗口），<code>HTMLIFrameElement.contentWindow</code>（<code>&lt;iframe&gt;</code>从其父窗口引用嵌入式），<code>Window.parent</code>（从嵌入式内部引用父窗口<code>&lt;iframe&gt;</code>）<code>Window.frames</code> +索引值（命名或数字）。</p>
</li>
<li><p><em>message</em></p>
<p>要发送到其他窗口的数据。使用结构化克隆算法序列化数据。这意味着您可以将各种各样的数据对象安全地传递到目标窗口，而无需自己序列化。</p>
</li>
<li><p><em>targetOrigin</em></p>
<p>指定要调度的事件的<code>targetWindow</code>的原点，可以是文字字符串<code>&quot;*&quot;</code>（表示没有首选项），也可以是URI。如果在计划调度事件时，<code>targetWindow</code>文档的方案，主机名或端口与<code>targetOrigin</code>提供的内容不匹配，则不会调度该事件；只有当所有的三个条件都匹配时，将调度该事件。该机制可以控制发送消息的位置；例如，如果<code>postMessage()</code>用于传输密码，则该参数必须是URI，其来源与包含密码的消息的预期接收者相同，以防止恶意第三方拦截密码。<strong>始终提供具体的targetOrigin，而不是*，如果您知道其他窗口的文档应该位于何处。未能提供特定目标会泄露您发送给任何感兴趣的恶意站点的数据。</strong></p>
</li>
<li><p><em>stransfer</em>（可选的）</p>
<p>是与消息一起传输的<code>Transferable</code>对象序列。这些对象的所有权将提供给目标端，并且它们在发送端不再可用。</p>
</li>
</ul>
</blockquote>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">var</span> popup = <span class="hljs-built_in">window</span>.open(<span class="hljs-string">&#x27;http://bbb.com&#x27;</span>, <span class="hljs-string">&#x27;title&#x27;</span>);<br>popup.postMessage(<span class="hljs-string">&#x27;Hello World!&#x27;</span>, <span class="hljs-string">&#x27;http://bbb.com&#x27;</span>);<br></code></pre></td></tr></table></figure>

<p>postMessage 的参数是：</p>
<ul>
<li>1、发送的内容</li>
<li>2、接收消息的窗口源，设为 * 时，表示向所有窗口发送。</li>
</ul>
<p>父子窗口均可以通过监听 message 事件来获取消息：</p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arcade">window.addEventListener(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(e.data);<br>&#125;,<span class="hljs-literal">false</span>);<br></code></pre></td></tr></table></figure>

<p>message 事件相关的对象有下面属性：</p>
<ul>
<li><code>event.source</code>：对发送消息的<code>window</code>对象的引用，也就是想要给其发送消息的一方，即上面的 targetWindow。</li>
<li><code>event.origin</code>: 调用当时发送消息的窗口的原点<code>postMessage</code>，即信息来源的一方。</li>
<li><code>event.data</code>: 消息内容</li>
</ul>
<p>接下来我们创建一个父子窗口交互的代码示例：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs xml">// 父窗口 http://127.0.0.1/frametest/test.html<br> <span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;http://127.0.0.1:8086/child.html&quot;</span> <span class="hljs-attr">frameborder</span>=<span class="hljs-string">&quot;0&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">     <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;message&#x27;</span>, receiveMessage);</span><br><span class="language-javascript"></span><br><span class="language-javascript">     <span class="hljs-keyword">function</span> <span class="hljs-title function_">receiveMessage</span>(<span class="hljs-params">event</span>) &#123;</span><br><span class="language-javascript">         <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">write</span>(<span class="hljs-string">&#x27;this is receiver\&#x27;s receiving data&#x27;</span> + event.<span class="hljs-property">data</span>);</span><br><span class="language-javascript"></span><br><span class="language-javascript">      &#125;</span><br><span class="language-javascript"> </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>// 子窗口 http://127.0.0.1:8086/child.html<br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">      <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;message&#x27;</span>, receiveMessage);</span><br><span class="language-javascript"></span><br><span class="language-javascript">      <span class="hljs-keyword">function</span> <span class="hljs-title function_">receiveMessage</span>(<span class="hljs-params">event</span>) &#123;</span><br><span class="language-javascript">          event.<span class="hljs-property">source</span>.<span class="hljs-title function_">postMessage</span>(<span class="hljs-string">&#x27;message_received&#x27;</span>, event.<span class="hljs-property">origin</span>);</span><br><span class="language-javascript">          <span class="hljs-title function_">alert</span>(event.<span class="hljs-property">data</span>);</span><br><span class="language-javascript"></span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>然后在父窗口向子窗口发送信息：(注意我们此时需要先拿到 iframe 标签，通过它来向子窗口发送数据)</p>
<p><img   class="lazyload" data-original="https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/jsonp/9.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ></p>
<p><img   class="lazyload" data-original="https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/jsonp/10.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ></p>
<p><img   class="lazyload" data-original="https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/jsonp/11.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ></p>
<h3 id="2-4-补充"><a href="#2-4-补充" class="headerlink" title="2.4 补充"></a>2.4 补充</h3><p>尽管有同源策略，但是在浏览器中，<code>&lt;script&gt;</code> <code>img</code> <code>iframe</code> <code>&lt;link&gt;</code> 等标签依旧可以跨域加载资源，不受同源策略的控制。一般都是带 <strong>src</strong> 属性的标签，它们加载资源时，其实是由浏览器发出了一次 GET 请求。</p>
<p>除了上面规避同源策略的方法外，还有几种：</p>
<ul>
<li>flash插件发送 http 请求，但必须安装 flash ，和 flash 交互。而现在 flash 已经用的越来越少了，在这里就不细究，有兴趣的同学可以参考道哥书里面的第二章内容。</li>
<li>可以在同源服务器下架设一个代理服务器来转发，代理服务器负责请求跨域内容，而 js 只负责接收即可。</li>
<li>第三种方式即是我们下面要探讨的 JSONP。</li>
</ul>
<h2 id="3-JSONP-介绍"><a href="#3-JSONP-介绍" class="headerlink" title="3@ JSONP 介绍"></a>3@ JSONP 介绍</h2><p> JSONP 即 JSON with Padding（填充式 JSON），是应用 JSON 的一种新的方法，常用于服务器和客户端跨源通信，在后来的 Web 服务中非常流行。</p>
<h3 id="3-1-基础知识"><a href="#3-1-基础知识" class="headerlink" title="3.1 基础知识"></a>3.1 基础知识</h3><p>JSONP 的基本思想就是，网页添加一个 <code>&lt;script&gt;</code> 标签，然后向服务器请求数据，服务器传送回来的数据放到请求时 <code>callback</code> 关键字函数中进行处理。这种方法不受同源策略的限制。JSONP 有个要求，就是只能用 GET请求，并且要求返回 Javascript，常见可以被浏览器解析为 js 的数据 mime 类型<a target="_blank" rel="noopener" href="https://mathiasbynens.be/demo/javascript-mime-type">在这</a>,实际上也就是我们上面补充点中说的，<code>&lt;script&gt;</code> 等标签可以跨域加载资源。</p>
<p>我们来看一个例子：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 构造一个加载跨域数据的脚本，来读取当前价格指数</span><br> function refreshPrice(<span class="hljs-keyword">data</span>) &#123; <span class="hljs-comment">//构造回调函数</span><br>            <span class="hljs-keyword">var</span> p = $(<span class="hljs-string">&#x27;p#content&#x27;</span>).<span class="hljs-keyword">get</span>(<span class="hljs-number">0</span>);<br>            p.innerHTML = <span class="hljs-string">&#x27;当前价格&#x27;</span> +<br>                <span class="hljs-keyword">data</span>[<span class="hljs-string">&#x27;0000001&#x27;</span>].name + <span class="hljs-string">&#x27;: &#x27;</span> +<br>                <span class="hljs-keyword">data</span>[<span class="hljs-string">&#x27;0000001&#x27;</span>].price + <span class="hljs-string">&#x27;；&#x27;</span> +<br>                <span class="hljs-keyword">data</span>[<span class="hljs-string">&#x27;1399001&#x27;</span>].name + <span class="hljs-string">&#x27;: &#x27;</span> +<br>                <span class="hljs-keyword">data</span>[<span class="hljs-string">&#x27;1399001&#x27;</span>].price;<br>        &#125;<br>  <span class="hljs-keyword">var</span> js = document.createElement(<span class="hljs-string">&#x27;script&#x27;</span>);<br>  head = $(<span class="hljs-string">&#x27;head&#x27;</span>);<br>  js.src = <span class="hljs-string">&quot;http://api.money.126.net/data/feed/0000001,1399001？callback=refreshPrice&quot;</span>;<br>  head.append(js);  <span class="hljs-comment">// 添加标签，加载数据，触发回调函数</span><br></code></pre></td></tr></table></figure>

<p><img   class="lazyload" data-original="https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/jsonp/12.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ></p>
<p>从这个例子我们也可以看出来，JSONP 由两部分组成：</p>
<ul>
<li>回调函数</li>
<li>请求传入的数据</li>
</ul>
<p>再举一个我们生活中大概率会碰到的例子：百度。</p>
<p>百度搜索框也是利用了 JSONP 的技术，我们可以通过下面的查询 URL 看出端倪。</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>sp0.baidu.com<span class="hljs-regexp">/5a1Fazu8AA54nxGko9WTAnF6hhy/</span>su?wd=西电&amp;&amp;cb=a<br></code></pre></td></tr></table></figure>

<p>结果为：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">a</span>(<br>&#123;<br>&quot;<span class="hljs-selector-tag">q</span>&quot;: <span class="hljs-string">&quot;西电&quot;</span>,<br><span class="hljs-string">&quot;p&quot;</span>: false,<br><span class="hljs-string">&quot;s&quot;</span>: [<br><span class="hljs-string">&quot;西电教务处&quot;</span>,<br><span class="hljs-string">&quot;西电睿思&quot;</span>,<br><span class="hljs-string">&quot;西电迎新网&quot;</span>,<br><span class="hljs-string">&quot;西电图书馆&quot;</span>,<br><span class="hljs-string">&quot;西电研究生&quot;</span>,<br><span class="hljs-string">&quot;西电研究生系统&quot;</span>,<br><span class="hljs-string">&quot;西电研究生院&quot;</span>,<br><span class="hljs-string">&quot;西电信息化建设处&quot;</span>,<br><span class="hljs-string">&quot;西电电院&quot;</span>,<br><span class="hljs-string">&quot;西电就业信息网&quot;</span><br>]<br>&#125;<br>)<br></code></pre></td></tr></table></figure>

<p>s 其实就是搜索结果的匹配项，而 cb 这个参数就是请求资源后的回调函数。</p>
<h3 id="3-2-JSONP-实现-ajax-的跨域请求"><a href="#3-2-JSONP-实现-ajax-的跨域请求" class="headerlink" title="3.2 JSONP 实现 ajax 的跨域请求"></a>3.2 JSONP 实现 ajax 的跨域请求</h3><p>我们知道，原生 Js 的 ajax 异步请求是有同源策略所限制的，但是有了 JSONP，我们便可以实现跨域请求。</p>
<p>接下来我们构造另一个域的生成 json 内容的 php 文件进行异步加载。</p>
<figure class="highlight php-template"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs php-template"><span class="language-xml">//127.0.0.1:8086/test.php</span><br><span class="language-xml"></span><span class="language-php"><span class="hljs-meta">&lt;?php</span></span><br><span class="language-php"><span class="hljs-variable">$data</span> = <span class="hljs-keyword">array</span>(</span><br><span class="language-php">    <span class="hljs-string">&#x27;age&#x27;</span>=&gt;<span class="hljs-number">20</span>,</span><br><span class="language-php">    <span class="hljs-string">&#x27;name&#x27;</span>=&gt;<span class="hljs-string">&#x27;rt95&#x27;</span></span><br><span class="language-php">);</span><br><span class="language-php"><span class="hljs-variable">$callback</span> = <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;callback&#x27;</span>];</span><br><span class="language-php"></span><br><span class="language-php"><span class="hljs-keyword">echo</span> <span class="hljs-variable">$callback</span>.<span class="hljs-string">&quot;(&quot;</span>.<span class="hljs-title function_ invoke__">json_encode</span>(<span class="hljs-variable">$data</span>).<span class="hljs-string">&quot;)&quot;</span>;</span><br><span class="language-php"><span class="hljs-keyword">return</span>;</span><br><span class="language-php"><span class="hljs-meta">?&gt;</span></span><span class="language-xml"></span><br><span class="language-xml">//127.0.0.1/frametest/test.html</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;jquery.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;content&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-keyword">function</span> <span class="hljs-title function_">handler</span>(<span class="hljs-params">data</span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-keyword">var</span> p = $(<span class="hljs-string">&#x27;p#content&#x27;</span>);</span></span><br><span class="language-javascript"><span class="language-xml">            p.<span class="hljs-title function_">html</span>(<span class="hljs-string">&#x27;name : &#x27;</span> + data.<span class="hljs-property">name</span> + <span class="hljs-string">&#x27;&lt;br&gt;&#x27;</span> + <span class="hljs-string">&#x27;age : &#x27;</span> + data.<span class="hljs-property">age</span>);</span></span><br><span class="language-javascript"><span class="language-xml">        &#125;</span></span><br><span class="language-javascript"><span class="language-xml">        $(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">            $.<span class="hljs-title function_">ajax</span>(&#123;</span></span><br><span class="language-javascript"><span class="language-xml">                <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;GET&#x27;</span>,</span></span><br><span class="language-javascript"><span class="language-xml">                <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;http://127.0.0.1:8086/test.php&#x27;</span>,</span></span><br><span class="language-javascript"><span class="language-xml">                <span class="hljs-attr">dataType</span>: <span class="hljs-string">&#x27;jsonp&#x27;</span>,</span></span><br><span class="language-javascript"><span class="language-xml">                <span class="hljs-attr">jsonp</span>: <span class="hljs-string">&#x27;callback&#x27;</span>, <span class="hljs-comment">// 请求 php 的参数名</span></span></span><br><span class="language-javascript"><span class="language-xml">                <span class="hljs-attr">jsonpCallback</span>: <span class="hljs-string">&#x27;handler&#x27;</span> <span class="hljs-comment">// 回调函数名 </span></span></span><br><span class="language-javascript"><span class="language-xml">            &#125;);</span></span><br><span class="language-javascript"><span class="language-xml">        &#125;);</span></span><br><span class="language-javascript"><span class="language-xml">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span><br></code></pre></td></tr></table></figure>

<p>运行文件！走你～你是不是发现了报错？长下面这样：</p>
<p><img   class="lazyload" data-original="https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/jsonp/13.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ></p>
<p>我们可以看到是被 CORS 这个规则给阻止了，那，什么是 CORS 呢？</p>
<h3 id="3-3-CORS-跨域资源共享"><a href="#3-3-CORS-跨域资源共享" class="headerlink" title="3.3 CORS (跨域资源共享)"></a>3.3 CORS (跨域资源共享)</h3><blockquote>
<p>如果浏览器支持HTML5，那么就可以一劳永逸地使用新的跨域策略：CORS了。</p>
<p>CORS全称Cross-Origin Resource Sharing，是HTML5规范定义的如何跨域访问资源。</p>
</blockquote>
<p>首先，我们需要了解：</p>
<p>Origin 表示的是本域，就是浏览器当前页面的域。我们看图说话：</p>
<p><img   class="lazyload" data-original="https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/jsonp/14.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ></p>
<p>假如我们的本域是 my.com ，待请求的外域为 sina.com，那么只要服务器端的响应头的 <strong>Access-Control-Allow-Origin</strong> 字段有我们的本域，亦或是通配符 * ，本次请求就可以成功。</p>
<p>像 POST ，GET 这样的简单请求只需验证这个字段即可，但是像 PUT，DELETE 等请求，在发送 ajax 之前，浏览器还会先发出一个 OPTION 请求，类似下面这样：</p>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs oxygene">OPTIONS /path/<span class="hljs-keyword">to</span>/resource HTTP/<span class="hljs-number">1.1</span><br>Host: bar.com<br>Origin: http:<span class="hljs-comment">//my.com</span><br>Access-Control-Request-<span class="hljs-keyword">Method</span>: POST<br></code></pre></td></tr></table></figure>

<p>服务器端会给出允许响应的请求类型：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-number">200</span> OK<br><span class="hljs-attribute">Access-Control-Allow-Origin</span><span class="hljs-punctuation">: </span>http://my.com<br><span class="hljs-attribute">Access-Control-Allow-Methods</span><span class="hljs-punctuation">: </span>POST, GET, PUT, OPTIONS<br><span class="hljs-attribute">Access-Control-Max-Age</span><span class="hljs-punctuation">: </span>86400<br></code></pre></td></tr></table></figure>

<p>如果我们刚开始的请求是在字段 <strong>Access-Control-Allow-Methods</strong> 里面，那么浏览器就会继续发送 ajax 请求，否则会抛出错误，终止操作。</p>
<p>有了这些知识，我们就可以很轻松的解决上面的问题了。修改一下服务端的脚本，添加返回头的 <strong>Access-Control-Allow-Origin</strong> 字段。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-title function_ invoke__">header</span>(<span class="hljs-string">&quot;Access-Control-Allow-Origin:*&quot;</span>);<br><span class="hljs-variable">$data</span> = <span class="hljs-keyword">array</span>(<br>    <span class="hljs-string">&quot;age&quot;</span>=&gt;<span class="hljs-number">20</span>,<br>    <span class="hljs-string">&quot;name&quot;</span>=&gt;<span class="hljs-string">&#x27;rt95&#x27;</span><br>);<br><span class="hljs-variable">$callback</span> = <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;callback&#x27;</span>];<br><span class="hljs-keyword">echo</span> <span class="hljs-variable">$callback</span>.<span class="hljs-string">&quot;(&quot;</span>.<span class="hljs-title function_ invoke__">json_encode</span>(<span class="hljs-variable">$data</span>).<span class="hljs-string">&quot;)&quot;</span>;<br><span class="hljs-keyword">return</span>;<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure>

<p><img   class="lazyload" data-original="https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/jsonp/15.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ></p>
<p>这里有两个点需要注意下：</p>
<ul>
<li>dataType 的 T 是大写，一定要注意！！</li>
<li>请求界面一定要给返回页面中调用 callback 指定的函数，具体实现根据不同需要而定。</li>
</ul>
<h2 id="4-JSONP-的劫持"><a href="#4-JSONP-的劫持" class="headerlink" title="4@ JSONP 的劫持"></a>4@ JSONP 的劫持</h2><h3 id="4-1-漏洞原理"><a href="#4-1-漏洞原理" class="headerlink" title="4.1 漏洞原理"></a>4.1 漏洞原理</h3><p>介绍了这么多知识，接下来我们就来介绍如何具体利用这个可能的漏洞点。</p>
<p><img   class="lazyload" data-original="https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/jsonp/16.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ></p>
<p>其实上面这张图已经十分清晰的展示了 JSONP 的利用过程。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css">用户注册网站 <span class="hljs-selector-tag">B</span> -----&gt;<br>用户访问网站 <span class="hljs-selector-tag">A</span> -----&gt;<br><span class="hljs-selector-tag">A</span> 网站的恶意脚本功能是通过注册 Callback 函数来像 <span class="hljs-selector-tag">B</span> 网站发起请求,获得用户在 <span class="hljs-selector-tag">B</span> 上的信息 -----&gt;<br><span class="hljs-selector-attr">[这步能够获取到 B 网站的凭证是利用了 CORS 这个跨域策略，访问获取配置是否允许传递 cookie，然后进行后面的处理逻辑]</span><br><span class="hljs-selector-tag">B</span> 网站未做请求检测，返回用户数据 -----&gt;<br>数据上传至攻击者服务器<br></code></pre></td></tr></table></figure>

<h3 id="4-2-漏洞危害"><a href="#4-2-漏洞危害" class="headerlink" title="4.2 漏洞危害"></a>4.2 漏洞危害</h3><blockquote>
<p><strong>JSONP是一种敏感信息泄露的漏洞</strong>，经过攻击者巧妙而持久地利用，会对企业和用户造成巨大的危害。攻击者通过巧妙设计一个网站，<strong>网站中包含其他网站的JSONP漏洞利用代码</strong>，将链接通过邮件等形式推送给受害人，<strong>如果受害者点击了链接，则攻击者便可以获取受害者的个人的信息，如邮箱、姓名、手机等信息，</strong>这些信息可以被违法犯罪分子用作“精准诈骗”。对方掌握的个人信息越多，越容易取得受害人的信任，诈骗活动越容易成功，给受害人带来的财产损失以及社会危害也就越大。</p>
</blockquote>
<h3 id="4-3-漏洞利用"><a href="#4-3-漏洞利用" class="headerlink" title="4.3 漏洞利用"></a>4.3 漏洞利用</h3><p>要想利用 JSONP 漏洞，必须找到存在漏洞的接口，这个接口必须满足以下三个条件：</p>
<ul>
<li>泄露出了敏感的信息，如 email,username,严重甚至 token。</li>
<li>未检测 referer（可以绕过 HTML5 的 CORS 策略），或者验证方式不太严谨，正则写的不完善等等，譬如设置验证的 referer 为 <code>http://www.xxx.com</code>, 但是<code>http://www.xxx.com.evil.com</code> 依旧可以绕过限制。</li>
<li>未启用 token 验证。</li>
</ul>
<h4 id="寻找方法"><a href="#寻找方法" class="headerlink" title="寻找方法"></a>寻找方法</h4><p>我们可以使用如下方法来初步粗略的寻找可能存在漏洞的接口。</p>
<p>1、打开浏览器控制台的 Preseve log ,防止之前找到的结果被刷新的页面覆盖。</p>
<p><img   class="lazyload" data-original="https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/jsonp/17.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ></p>
<p>2、手动通过关键词筛选一些信息，搜索一些关键词，譬如 <code>callback</code>,<code>jsonp</code> 等，然后以此点进（确实慢，而且效率不高）。</p>
<p>3、这里以淘宝为例，我找到了一个没什么利用价值的页面，只是用来实现整个过程。</p>
<p><img   class="lazyload" data-original="https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/jsonp/18.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ></p>
<p>4、通过构造恶意代码，诱使登陆的用户访问，然后获得数据。（这里淘宝这个页面确实没做特殊的过滤和访问控制，可能是因为数据没什么利用价值）</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;jquery.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;content&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">        <span class="hljs-keyword">function</span> 【回调函数名】(data) &#123;</span><br><span class="language-javascript">            <span class="hljs-keyword">var</span> p = $(<span class="hljs-string">&#x27;p#content&#x27;</span>);</span><br><span class="language-javascript">            p.<span class="hljs-title function_">html</span>(<span class="hljs-string">&#x27;ip : &#x27;</span> + data.<span class="hljs-property">data</span>.<span class="hljs-property">ip</span> + <span class="hljs-string">&#x27;&lt;br&gt;&#x27;</span> + <span class="hljs-string">&#x27; region：&#x27;</span> + data.<span class="hljs-property">data</span>.<span class="hljs-property">region</span> + <span class="hljs-string">&#x27;&lt;br&gt;&#x27;</span> + <span class="hljs-string">&#x27; city: &#x27;</span> + data.<span class="hljs-property">data</span>.<span class="hljs-property">city</span>);</span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">        $(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">            $.<span class="hljs-title function_">ajax</span>(&#123;</span><br><span class="language-javascript">                <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;GET&#x27;</span>,</span><br><span class="language-javascript">                <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;接口名&#x27;</span>,</span><br><span class="language-javascript">                <span class="hljs-attr">dataType</span>: <span class="hljs-string">&#x27;jsonp&#x27;</span>,</span><br><span class="language-javascript">                <span class="hljs-attr">jsonp</span>: <span class="hljs-string">&#x27;callback&#x27;</span>, <span class="hljs-comment">// 请求 php 的参数名</span></span><br><span class="language-javascript">                <span class="hljs-attr">jsonpCallback</span>: <span class="hljs-string">&#x27;回调函数名&#x27;</span> <span class="hljs-comment">// 回调函数名 </span></span><br><span class="language-javascript">            &#125;);</span><br><span class="language-javascript">        &#125;);</span><br><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p><img   class="lazyload" data-original="https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/jsonp/19.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ><br>可以看到，数据已经跨域访问，并且输出到了页面上面，如果是敏感数据，危害确实是巨大的。</p>
<p>为了避免手动傻瓜寻找，我们可以编写爬虫脚本来自动化测试。</p>
<blockquote>
<p>（1）Selenium：可用于自动化对网页进行测试，“到处”点击按钮、超链接，以期待测试更多的接口；</p>
<p>（2）Proxy：用于代理所有的请求，过滤出所有包含敏感信息的<a target="_blank" rel="noopener" href="http://www.infosec-wiki.com/?tag=jsonp">JSONP</a>请求，并记录下HTTP请求；</p>
<p>（3）验证脚本：使用上述的HTTP请求，剔除referer字段，再次发出请求，测试返回结果中，是否仍包敏感信息，如果有敏感信息，说明这个接口就是我们要找的！</p>
</blockquote>
<p>引用的工具作者将工具放到了<a target="_blank" rel="noopener" href="https://github.com/qiaofei32/jsonp_info_leak">这</a>。</p>
<p><img   class="lazyload" data-original="https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/jsonp/20.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ></p>
<p>可以看到，速度和效率确实高出不少，但是还是需要一定程度的人工筛选。</p>
<h3 id="4-4-漏洞防御"><a href="#4-4-漏洞防御" class="headerlink" title="4.4 漏洞防御"></a>4.4 漏洞防御</h3><p>这个漏洞乍看起来利用起来很难。没错，随着网站开发者的安全意识的提升，接口过滤会愈来愈多，但是目前来看还是有很多存在缺陷的接口。想想，如果有个 xss 可利用，拿到 token 之类的数据， jsonp 的防御是否还是坚不可摧呢？</p>
<p>这里我们再补充一点，当服务端出现如下配置时，就算满足条件，服务端也会拒绝返回数据：</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">header(<span class="hljs-string">&quot;Access-Control-Allow-Origin: *&quot;</span>)<span class="hljs-comment">;</span><br>header(<span class="hljs-string">&quot;Access-Control-Allow-Credentials: true&quot;</span>)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>

<p>其中：</p>
<blockquote>
<p>对应客户端的 <code>xhrFields.withCredentials: true</code> 参数，服务器端通过在响应 header 中设置 <code>Access-Control-Allow-Credentials = true</code> 来运行客户端携带证书式访问。通过对 Credentials 参数的设置，就可以保持跨域 Ajax 时的 Cookie</p>
</blockquote>
<p>s防御方法：</p>
<ul>
<li>接口处限制 referer 字段，设置随机 token 等。</li>
<li>因为有直接利用 callback 函数进行的 xss攻击，我们还要严格控制编码，防止解析为 html ，要严格按照 JSON 格式标准输出 Content-Type 及编码（ Content-Type : application&#x2F;json; charset&#x3D;utf-8 ）。</li>
<li>严格过滤 callback 函数名及 JSON 里数据的输出。</li>
<li>不要使用cookies来自定义JSONP响应。</li>
<li>在 JSONP 响应中不要加入用户的个人敏感数据。</li>
<li>严谨配置 Access-Control-Allow-Origin 选项。</li>
</ul>
<p>Reference:</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs awk">&lt;白帽子讲web安全&gt;<br>https:<span class="hljs-regexp">//</span>www.liaoxuefeng.com<span class="hljs-regexp">/wiki/</span><span class="hljs-number">1022910821149312</span>/<span class="hljs-number">1023022332902400</span><br>http:<span class="hljs-regexp">//</span>www.ruanyifeng.com<span class="hljs-regexp">/blog/</span><span class="hljs-number">2016</span><span class="hljs-regexp">/04/</span>same-origin-policy.html<br>https:<span class="hljs-regexp">//</span>www.cnblogs.com<span class="hljs-regexp">/sdcs/</span>p/<span class="hljs-number">8484905</span>.html<br>https:<span class="hljs-regexp">//</span>blog.csdn.net<span class="hljs-regexp">/qq_38643434/</span>article<span class="hljs-regexp">/details/</span><span class="hljs-number">81430528</span><br>https:<span class="hljs-regexp">//</span>www.cnblogs.com<span class="hljs-regexp">/xiaohuochai/</span>p/<span class="hljs-number">6568039</span>.html<br>https:<span class="hljs-regexp">//</span>www.k0rz3n.com<span class="hljs-regexp">/2019/</span><span class="hljs-number">03</span><span class="hljs-regexp">/07/</span>JSONP%<span class="hljs-number">20</span>%E5%<span class="hljs-number">8</span>A%AB%E6%<span class="hljs-number">8</span>C%<span class="hljs-number">81</span>%E5%<span class="hljs-number">8</span>E%<span class="hljs-number">9</span>F%E7%<span class="hljs-number">90</span>%<span class="hljs-number">86</span>%E4%B8%<span class="hljs-number">8</span>E%E6%<span class="hljs-number">8</span>C%<span class="hljs-number">96</span>%E6%<span class="hljs-number">8</span>E%<span class="hljs-number">98</span>%E6%<span class="hljs-number">96</span>%B9%E6%B3%<span class="hljs-number">95</span>/<br>https:<span class="hljs-regexp">//</span>www.k0rz3n.com<span class="hljs-regexp">/2018/</span><span class="hljs-number">06</span><span class="hljs-regexp">/05/</span>%E7%<span class="hljs-number">94</span>%B1%E6%B5%<span class="hljs-number">85</span>%E5%<span class="hljs-number">85</span>%A5%E6%B7%B1%E7%<span class="hljs-number">90</span>%<span class="hljs-number">86</span>%E8%A7%A3JSONP%E5%B9%B6%E6%<span class="hljs-number">8</span>B%<span class="hljs-number">93</span>%E5%B1%<span class="hljs-number">95</span>/<br>https:<span class="hljs-regexp">//</span>www.freebuf.com<span class="hljs-regexp">/articles/</span>web/<span class="hljs-number">70025</span>.html<br>https:<span class="hljs-regexp">//</span>www.anquanke.com<span class="hljs-regexp">/post/i</span>d/<span class="hljs-number">97671</span><br>https:<span class="hljs-regexp">//</span>www.cnblogs.com<span class="hljs-regexp">/52php/</span>p/<span class="hljs-number">5677775</span>.html<br>https:<span class="hljs-regexp">//</span>www.infosec-wiki.com/?p=<span class="hljs-number">455211</span><br>https:<span class="hljs-regexp">//</span>blog.csdn.net<span class="hljs-regexp">/z69183787/</span>article<span class="hljs-regexp">/details/</span><span class="hljs-number">78954325</span><br>https:<span class="hljs-regexp">//</span>www.w3cschool.cn<span class="hljs-regexp">/fetch_api/</span>fetch_api-lx142x8t.html<br></code></pre></td></tr></table></figure>
      </section>
      <section class="extra">
        
          <ul class="copyright">
  
    <li><strong>本文作者：</strong>rt</li>
    <li><strong>本文链接：</strong><a href="https://rt-95.github.io/2021/01/19/%E8%A7%84%E9%81%BF%E6%B5%8F%E8%A7%88%E5%99%A8%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5%20&%20JSONP%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E5%88%A9%E7%94%A8/index.html" title="https:&#x2F;&#x2F;rt-95.github.io&#x2F;2021&#x2F;01&#x2F;19&#x2F;%E8%A7%84%E9%81%BF%E6%B5%8F%E8%A7%88%E5%99%A8%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5%20&amp;%20JSONP%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E5%88%A9%E7%94%A8&#x2F;index.html">https:&#x2F;&#x2F;rt-95.github.io&#x2F;2021&#x2F;01&#x2F;19&#x2F;%E8%A7%84%E9%81%BF%E6%B5%8F%E8%A7%88%E5%99%A8%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5%20&amp;%20JSONP%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E5%88%A9%E7%94%A8&#x2F;index.html</a></li>
    <li><strong>版权声明：</strong>本博客所有文章均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" title="BY-NC-SA" target="_blank" rel="noopener">BY-NC-SA</a> 许可协议，转载请注明出处！</li>
  
</ul>
        
        
        
        
  <nav class="nav">
    <a href="/2021/01/19/Gitea%20Stacks%20Overflow/"><i class="iconfont iconleft"></i>Gitea Stacks Overflow</a>
    <a href="/2020/12/11/Gogs%20%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/">Gogs 远程命令执行漏洞<i class="iconfont iconright"></i></a>
  </nav>

      </section>
      
        <section class="comments">
  
    <div class="btn" id="comments-btn">查看评论</div>
  
  
<div id="valine"></div>
<script defer src="//unpkg.com/valine/dist/Valine.min.js"></script>
<script>
  window.onload = function () {
    var loadValine = function () {
      new Valine({
        el: '#valine',
        app_id: "2p9C8apOcLBToxgiqqnJtF5v-gzGzoHsz",
        app_key: "r9A7GDDCd5SSLNdlcwqxdjvR",
        placeholder: "说点什么吧",
        avatar: "mp",
        pageSize: "10",
        lang: "zh-CN",
      });
    }
    if ( true ) {
      $("#comments-btn").on("click", function () {
        $(this).hide();
        loadValine();
      });
    } else {
      loadValine();
    }
  };
</script>

</section>
      
    </section>
  </div>
</article></div>
      <div class="col-xl-3">
        
          
  <aside class="toc-wrap">
    <h3 class="toc-title">文章目录：</h3>
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%89%8D%E8%A8%80"><span class="toc-text">1@ 前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5"><span class="toc-text">2@ 同源策略</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E4%BB%8B%E7%BB%8D"><span class="toc-text">2.1 介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E9%99%90%E5%88%B6%E8%8C%83%E5%9B%B4"><span class="toc-text">2.2 限制范围</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E8%A7%84%E9%81%BF%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">2.3 规避同源策略的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E8%A1%A5%E5%85%85"><span class="toc-text">2.4 补充</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-JSONP-%E4%BB%8B%E7%BB%8D"><span class="toc-text">3@ JSONP 介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-text">3.1 基础知识</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-JSONP-%E5%AE%9E%E7%8E%B0-ajax-%E7%9A%84%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82"><span class="toc-text">3.2 JSONP 实现 ajax 的跨域请求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-CORS-%E8%B7%A8%E5%9F%9F%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%AB"><span class="toc-text">3.3 CORS (跨域资源共享)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-JSONP-%E7%9A%84%E5%8A%AB%E6%8C%81"><span class="toc-text">4@ JSONP 的劫持</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86"><span class="toc-text">4.1 漏洞原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E6%BC%8F%E6%B4%9E%E5%8D%B1%E5%AE%B3"><span class="toc-text">4.2 漏洞危害</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8"><span class="toc-text">4.3 漏洞利用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-%E6%BC%8F%E6%B4%9E%E9%98%B2%E5%BE%A1"><span class="toc-text">4.4 漏洞防御</span></a></li></ol></li></ol>
  </aside>

        
      </div>
    </div>
  </div>
</main>
  

<footer class="footer">
  <div class="footer-social"><a 
        href="https://github.com/rt-95 "
        target="_blank"
        class="footer-social-item"
        onMouseOver="this.style.color= '#9f7be1'" 
        onMouseOut="this.style.color='#33333D'">
          <i class="iconfont  icongithub-fill "></i>
      </a><a 
        href="https://weibo.com/u/6479214985 "
        target="_blank"
        class="footer-social-item"
        onMouseOver="this.style.color=#00cc99" 
        onMouseOut="this.style.color='#33333D'">
          <i class="iconfont  iconweibo"></i>
      </a></div>
  
    <div class="footer-copyright"><p>Powered by <a target="_blank" href="https://hexo.io">rt</a>  |  Theme - <a target="_blank" href="https://github.com/izhaoo/hexo-theme-zhaoo">zhaoo</a></p></div>
  
</footer>
  
      <div class="fab fab-plus">
    <i class="iconfont iconplus"></i>
  </div>
  
  
  
  <div class="fab fab-up">
    <i class="iconfont iconcaret-up"></i>
  </div>
  
  
  
    
<script src="/js/color-mode.js"></script>

  
  
</body>

<script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>





  
<script src="https://cdn.bootcdn.net/ajax/libs/jquery.lazyload/1.9.1/jquery.lazyload.min.js"></script>




  
<script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js"></script>






  
<script src="https://cdn.bootcdn.net/ajax/libs/jquery.qrcode/1.0/jquery.qrcode.min.js"></script>




<script src="/js/utils.js"></script>
<script src="/js/script.js"></script>







  <script>
    (function () {
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
      } else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>













</html>